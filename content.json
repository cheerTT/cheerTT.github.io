{"meta":{"title":"cheerttの个人博客","subtitle":"记录学习、分享生活","description":"不是学霸，但也不渣","author":"cheertt","url":"http://cheertt.top"},"pages":[],"posts":[{"title":"一次刷到爽——单调栈","slug":"一次刷到爽——单调栈","date":"2020-07-30T15:35:53.202Z","updated":"2020-07-31T14:38:22.386Z","comments":true,"path":"p/23036.html","link":"","permalink":"http://cheertt.top/p/23036.html","excerpt":"","text":"一次刷到爽——单调栈 所谓单调栈就是栈里面存在的数据都是递增或者递减的，当想要push一个违背上述规则的元素时，需要不断移除栈顶元素知道满足上述规则后再push该元素。 根据上述描述，可以总结出的通用代码模板如下： 1234567891011121314151617public int commonStack(int[] nums) &#123; int res = 0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; // 判断当前栈不满足递增条件，不听出栈 while (!stack.isEmpty() &amp;&amp; nums[stack.peek()] &gt; nums[i]) &#123; int curId = stack.pop(); // ... &#125; // 知道满足递增栈条件才插入 stack.push(i); &#125; return res;&#125; 单调栈这种数据结构，通常应用于一位数组上。如果遇到的问题和前后元素之间的大小关系有关的话，可以尝试使用单调栈解决。使用单调栈解决的题目，时空复杂度一般均是O(n)。 下面，来看看《剑指offer》第33题，二叉搜索树的后续遍历序列 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。 输入: [1,6,3,2,5]输出: false 输入: [1,3,2,6,5]输出: true 针对二叉搜索树的后续遍历序列是按照左-右-根的顺序遍历。可以发现从后往前的顺序列就是分别经过根节点，右字树，左子树。由于二叉搜索树的左子树节点小于根节点小于右字树节点。我们从后向前遍历后序序列，将根节点和右字树节点入栈（我们维护一个递增栈，因为右字树节点总是大于根节点的），当出现小于当前栈顶元素的值时，我们弹出栈维护一个新的递增栈。 结合上述commonStack代码模板，代码如下： 12345678910111213141516171819public boolean verifyPostorder(int[] postorder) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;; // 假设初始根节点无限大 int root = Integer.MAX_VALUE; for (int i = postorder.length - 1; i &gt;= 0; i--) &#123; // 左子树节点大于根节点 if (postorder[i] &gt; root) return false; // 将当前 root 节点的所有右字树节点入栈 while(!stack.isEmpty() &amp;&amp; stack.peek() &gt; postorder[i]) &#123; root = stack.pop(); &#125; stack.push(postorder[i]); &#125; return true;&#125; 下面再看看字节跳动面试官问到烂的接雨水(leetcode 42) 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 输入: [0,1,0,2,1,0,1,3,2,1,2,1]输出: 6 该题目有很多解法，详情可到此处查看，这里我们只讨论单调栈解法。 维护一个递减栈，累加统计能接到的最大雨水量。 123456789101112131415161718public int trap(int[] height) &#123; int res = 0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for (int i = 0; i &lt; height.length; i++) &#123; while (!stack.isEmpty() &amp;&amp; height[stack.peek()] &lt; height[i]) &#123; int curId = stack.pop(); if (!stack.isEmpty()) &#123; res += (Math.min(height[i], height[stack.peek]) - height[curId]) * (i - stack.peek() - 1); &#125; &#125; stack.push(i); &#125; return res;&#125; 下面再看看华为面试过程中遇到的两道问题：柱状图的最大面积(leetcode 84) 和 去除重复字母(leetcode 316) 对于柱状图的最大面积，最大矩形的面积的总是和相邻矩形块的的高度相关，为此我们可以维护一个递增栈来解决，因为我们要计算的是凸出来的最大面积所以用递增栈，而接雨水要计算的是凹进去的最多雨水所以用递减栈。 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。 输入: [2,1,5,6,2,3]输出: 10 结合一开始给出的commonStack代码模板，可得到代码如下： 1234567891011121314151617181920public int largestRectangleArea(int[] heights) &#123; int res = 0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); // 扩展两边。为了便于计算 int[] n_heights = new int[heights.length + 2]; System.arraycopy(heigths, 0, n_heights, 1, heights.length); for (int i = 0; i &lt; n_heights.length; i++) &#123; while (!stack.isEmpty &amp;&amp; n_heights[stack.peek()] &gt; n_heights[i]) &#123; int curId = stack.pop(); res = Math.max(res, (i - stack.peek() - 1) * n_height[curId]); &#125; stack.push(i); &#125; return res;&#125; 对于去除重复字母，此类题目都有一个限定条件——保持字符的相对位置不变。由于要保持字典序最小，那肯定用递增栈且栈中存放的就是满足最终条件的解。 给你一个仅包含小写字母的字符串，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证返回结果的字典序最小（要求不能打乱其他字符的相对位置）。 输入: “bcabc”输出: “abc” 输入: “cbacdcbc”输出: “acdb” 12345678910111213141516171819public String removeDuplicateLetters(String s) &#123; StringBuilder sb = new StringBuilder(); Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); for (int i = 0; i &lt; s.length(); i++) &#123; while (!stack.isEmpty() &amp;&amp; stack.peek(i) &gt; s.charAt(i) &amp;&amp; s.indexOf(stack.peek(), i) &gt; 0) &#123; stack.pop(); &#125; stack.push(s.charAt(i)); &#125; for (Character c : stack) &#123; sb.append(c); &#125; return sb.toString();&#125; 下面还有几道题目也可以用单调栈解决，思路大同小异。 每日温度(leetcode 739) 请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。 输入 [73, 74, 75, 71, 69, 72, 76, 73]输出 [1, 1, 4, 2, 1, 1, 0, 0] 1234567891011121314151617// 当前气温往后更高的气温，不算本身，维护递减栈计算public int[] dailyTemperatures(int[] T) &#123; int[] res = new int[T.length]; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for (int i = 0; i &lt; T.length; i++) &#123; while (!stack.isEmpty() &amp;&amp; stack.peek() &lt; T[i]) &#123; int curId = stack.pop(); res[curId] = (i - curId); &#125; stack.push(i); &#125; return res;&#125; 股票价格的跨度(leetcode 901) 编写一个 StockSpanner 类，它收集某些股票的每日报价，并返回该股票当日价格的跨度。今天股票价格的跨度被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。 输入 [100, 80, 60, 70, 60, 75, 85]输出 [1, 1, 1, 2, 1, 4, 6]。 123456789101112131415161718192021222324// 维护一个递减栈，包含当前class StockSpanner &#123; Stack&lt;Integer&gt; stack; Stack&lt;Integer&gt; cache; public StockSpanner() &#123; stack = new Stack&lt;&gt;(); cache = new Stack&lt;&gt;(); &#125; public int next(int price) &#123; int ans = 1; while (!stack.isEmpty() &amp;&amp; stack.peek() &lt;= price) &#123; stack.pop(); ans += cache.pop(); &#125; // 若是递减的，直接插入1； stack.push(price); cache.push(ans); return ans; &#125;&#125; 最短无序连续子数组(leetcode 581) 给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。你找到的子数组应是最短的，请输出它的长度。 输入: [2, 6, 4, 8, 10, 9, 15]输出: 5解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。 123456789101112131415161718192021222324252627// 对于该题，需要分别从左往右和从右往左寻找第一个发生交换的位置（表示不是正常排序）public int findUnsortedSubarray(int[] nums) &#123; int left = nums.length; int right = -1; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); // 递增栈 for (int i = 0; i &lt; nums.length; i++) &#123; while (!stack.isEmpty() &amp;&amp; nums[stack.peek()] &gt; nums[i]) &#123; left = Math.min(left, stack.pop()); &#125; stack.push(i); &#125; stack = new Stack&lt;&gt;(); // 递减栈 for (int i = nums.length - 1; i &gt;= 0; i--) &#123; while (!stack.isEmpty() &amp;&amp; nums[stack.peek()] &lt; nums[i]) &#123; right = Math.max(right, stack.pop()); &#125; stack.push(i); &#125; return left &lt; right ? right - left + 1 : 0;&#125; 下一个更大的元素(leetcode 496) 给定两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。 输入: nums1 = [4,1,2], nums2 = [1,3,4,2].输出: [-1,3,-1]解释: 对于num1中的数字4，你无法在第二个数组中找到下一个更大的数字，因此输出 -1。 对于num1中的数字1，第二个数组中数字1右边的下一个较大数字是 3。 对于num1中的数字2，第二个数组中没有下一个更大的数字，因此输出 -1。 12345678910111213141516171819202122232425public int[] nextGreaterElement(int[] nums1, int[] nums2) &#123; int[] res = new int[nums1.length]; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums2.length; i++) &#123; while (!stack.isEmpty() &amp;&amp; stack.peek() &lt; nums2[i]) &#123; map.put(stack.pop(), nums2[i]); &#125; stack.push(nums2[i]); &#125; for (int i = 0; i &lt; nums1.length; i++) &#123; if (map.containsKey(nums1[i])) &#123; res[i] = map.get(nums1[i]); &#125; else &#123; res[i] = -1; &#125; &#125; return res;&#125; 移调k位数字(leetcode 402) 给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。 输入: num = “1432219”, k = 3输出: “1219”解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。 123456789101112131415161718192021222324252627282930313233public String removeKdigits(String num, int k) &#123; int comp = num.length() - k; StringBuilder res = new StringBuilder(); Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); for (int i = 0; i &lt; num.length(); i++) &#123; while (k != 0 &amp;&amp; !stack.isEmpty() &amp;&amp; stack.peek() &gt; num.charAt(i)) &#123; stack.pop(); k--; &#125; stack.push(num.charAt(i)); &#125; // 处理 \"9\" 1 这样的情况 while (stack.size() &gt; comp) &#123; stack.pop(); &#125; for (Character c : stack) &#123; res.append(c); &#125; // 去除先导 \"0\" String r = res.toString(); int m = 0; while (m &lt; r.length() &amp;&amp; r.charAt(m) == '0') &#123; m++; &#125; return m == r.length() ? \"0\" : r.substring(m);&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://cheertt.top/categories/algorithm/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://cheertt.top/tags/笔记/"},{"name":"算法","slug":"算法","permalink":"http://cheertt.top/tags/算法/"}],"keywords":[{"name":"algorithm","slug":"algorithm","permalink":"http://cheertt.top/categories/algorithm/"}]},{"title":"彭明辉-研究生手册","slug":"彭明辉-研究生手册","date":"2019-07-28T00:45:54.115Z","updated":"2020-07-31T14:29:18.421Z","comments":true,"path":"p/46253.html","link":"","permalink":"http://cheertt.top/p/46253.html","excerpt":"","text":"我是在研一暑假这个阶段看到的彭明辉教授的研究生手册，在研究生的这个阶段，看这个可谓是再适合不过。自己研究方向的相关论文已经看了大半年，已经到了快准备毕业论文开题答辩的节点，这本书让我提前了解写论文过程中的每个阶段，以及会经历的一些细节。 下面是我在阅读过程中，从书中摘录的一些极大触动我的句子。判断一本书是否有价值，在人生所处阶段以及人生经历是分不开的，所以大佬们推荐的书单固然有其理由，但永远需要明确的是，符合当前自己需求的书才是最适合自己的书。 1 达摩面壁，慧可立雪九成的力气爬到巨人得肩膀上，一成的力气用在活用。 解决问题最快、最省钱且风险最小的办法就是抄袭既有，而非创新。研究的方法与目的就是为问题寻找正确的或较可靠的答案，或者为问题找到更好的解决方案。这一套方法与程序可以用来解决产业界、政府机构和学术界的问题，也可以用来解决人生中的其他关键问题。 研究的过程始于文献回顾，创意是用来走完最后一里路。先从文献回顾去了解前人的失败经验和教训，避免重蹈覆辙，藉此降低风险；接着吸收前人的智慧，站在巨人的肩膀上，先立于不败之地；最后才是分析既有答案的缺点与不足，用自己的创意（聪明和运气）想出改进的办法，以便推陈出新。 2 黄金与粪土——学术著作的要件学位论文的第一要件是原创新或新颖性，整本论文都是为了要报告过去学术界尚未发现的事情或者推翻、修正过去学术界普遍相信的事件或。学位论文的第二要见是严谨性与客观性。 学术研究的核心能力：创新的能力、自我批判的能力、文献回顾的能力。 学术圈始终在追求真理，以及摆脱一切因为时间、空间、文化或个人特质而造成的主观、偏见，并且一直都在企图通过演绎方法将知识条理化或系统化。 一般硕士训练的重点在于文献回顾和自我批判的能力，对论文的原创新不高，略有所成即可。 学术论文必须兼具7项要见：（1）原创性；（2）可靠的证据支持；（3）批判性的检视过程里；（4）理论性、系统性与一致性；（5）客观性与可重复性；（6）根学术界的明确关系与对话；（7）清晰的文采与叙述。学术研究的核心能力有三项：创新的能力、批判性思考以及文献回顾能力，其中批判性思考必须与领域内知识紧密结合。为了培养出这三种能力，你需要负责的指导教授、好的学习环境和认真的学习过程。 3 山中无厉日，寒尽不知年——研究的历程和时间表寻找跟主题相关的关键词，搜索相关论文，替升自己的文献检索能力。勾勒出学术界研究这个问题所采用的所有方法，以及这些方法背后的原因与机制。创新，最简单的方法就是，取长补短，糅合 研究过程中第一大阶段性目标既有学术论文中的共识与争论以及各个流派的大致特色与优缺点；研究过程中第二大阶段性目标提出创新的策略与研究构想，并且完成可行性的评估与完整的文献回顾；研究过程中第三大阶段性目标完成理论发展，整合各种论据，反复检验与论证假说中的答案或解决方案，并且据以调整假说、假设条件与适用范围，直到有足够的贡献以及找不到弱点为止。论文品质的真正差别往往不在于他们最后的答案，而是在于他们回答的方式和论据有多严谨、可靠——最著名的论文不必然是最富有创意的，但一定是最严谨而让人不得不信服的。 4 恩师与廉价劳工——指导教授与研究能力的养成批判性思考的6种能力：（1）分析论证、概念、方法和问题脉络的能力；（2）评估论据、方法、结果的价值和可靠性等；（3）对各种论据与事实进行完整的演绎与归纳等推理，以产出新的结论或命题、发现；（4）解释各种论据的内在关系或可能的因果连结，以形成规律或理论；（5）诠释与解释各种论据、概念、理论与研究结果的内在内涵和可能衍生的影响、重要性与价值等；（6）有能力自行引导与组织自己的思考活动，以便选择研究方法，规则研究活动，寻找论据，从论据产出可靠的结论或判断，并且在这过程中侦测出自己隐藏的假设或前提，跳跃的推断等错误；指导教授的责任是培育你自己解决问题的能力，而不是替你解决问题。 5 万绿丛中一点儿红——研究主题与论文题目的关系每一种研究主题都包含非常多样的论文题目，足以满足各种不同的兴趣和专长，可以适合每一个人的特质和兴趣。因此，最好是尽快决定研究主题，以便有较多的时间去决定论文题目。 6 告别大学时代——期刊论文的阅读服务螺旋式阅读法——最自然最省力的方法。第一次阅读论文时，最主要聚焦在三个最容易回答的问题：（1）这篇论文想解决什么问题？最适合描述该问题的术语是什么？（2）它使用的方法是什么？学术界如何称呼他？（3）前述的问题和方法属于哪一个学术领域？回答上述三个问题，主要到论文的题目、摘要和引言中寻找答案。 千万别爬峭壁——读懂一篇期刊论文的多种途径。阅读期刊论文不应该以论文为中心，而要以问题为中心。第一次阅读的时候，只想办法读懂最粗浅、易懂的部分，藉此判断你所需要的其他背景知识，并且找到相关的科普级文件阅读，以提升背景知识。第二次阅读时，设法确定这篇论文所属的学术领域、使用的方法，想解决的问题，以及最适合用来描述他们的学术领域、使用的方法，想解决的问题，以及适合用来描述他们的学术术语，然后找出相关的入门级学术文件来阅读，进一步提升背景知识。第三次阅读后应该可以读懂论文的一两层，你可以据此去找出跟这论文主题或方法较接近易读的书或硕博士论文，找出书中较密切相关的章节、页码和段落，不吃力的读过一次，藉此增加较深入的专业知识。第四次阅读后可能读懂论文的三四层，然后去粗略读过这一片论文后面的参考文献，找到有助于你进一步理解原来期刊论文的段落，并读完他们。第五次阅读后可能可以读懂七八层，且有能力研判自己欠缺的其他背景知识。然后，你上网找出对你有用的论文、报告，只挑对你有用的章节阅读，再加上自己的分析理解与推理能力，以便把论文最后的部分读懂与想通。 7 鸟瞰全局——总览式文献回顾与田野文献回顾的第一步是鸟瞰全局，找到最有机会突破的研究焦点或研究子题，同时试着回答以下问题：（1）这个研究的焦点与哪些研究字题相关？如何关联？（2）在这个研究焦点和各种相关研究子题上，有过哪些主要的研究角度？哪些主要的主张和流派？（3）这些角度、主张与流派各有何优缺点？他们各自举出过哪些有利于自己的论据？彼此举出过哪些不利于对方的论据？（4）你对于这个研究焦点有何想法？既有论据有哪些是支持你的想法？有哪些论据可能不利于你的想法？（5）假如你试着调整对这个研究焦点的看法，有没有机会找到更多论据来支持自己的想法？还是可以反过来找到其他竞争者的弱点，来强化自己的主张？ 鸟瞰全局的利器——总览式文献回顾与回顾型论文简介。学术界的论文主要可以分为两大类，第一类是针对新的问题，提出原创性的新理论、新论据或新的解决方案，这类论文明确聚焦在一个范围很小的研究子题上，以及跟这个小范围的研究子题有关的文献；第二类是回顾型论文，它旨在从鸟瞰的角度，介绍一个研究主题内的各种既有的研究成果与现状 研究工作与文献回顾的第一步，是利用回顾型论文了解一个研究生主题的梗概，包括问题背景与学术研究的起源，主要的发展历程、研究子题的相互关联、各种观点与流派，重要的代表著作与研究成果，各家各派的主要争论与共识，以及最新的研究课题和发展趋势。文献回顾的目的，并非知识消极地吸收文献中地知识并加以整理，而是为了要回答你自己所提出来地问题（疑点或假说）以及激励进一步地思考与创意。好的研究程序应该是由粗而细且由浅而深地发问、阅读与思考，因此在决定研究题目之前，没必要仔细揣摩任何难懂地原创性期刊论文。 8 众里寻他千百度——论文题目与研究范围研究题目的两种基本类型是为问题寻找正确的答案，或有效的解决方案。 9 青出于蓝——批判与创新的要领（上）决定论文题目和研究范围后，下一个工作就是文献回顾，目的就是回答两个问题：（1）在你拟定的论文题目和研究范围内，有哪些既有的答案或解决方案？既有知识的边界在哪里？（2）前述的既有答案中，有哪些确实可行而毋庸重复？哪些回答论据不足、观点偏颇 文献回顾有两大重要功能，其一是完善批判与检视的原则与要领，其二是通过文献回顾开发更多创新的想法。最后讲创意和批判原则合成一个严谨而有价值的研究设计。研究的创新主要有两种类型，以新的论据、观点或较严谨的方法重新探索旧的题目，而有新颖的发现；或者以既有的方法适度修改后，去探究新的研究领域、题目而造成的新的发现。 10 青出于蓝——批判与创新的要领（中）方法没有绝对的好坏，只有相对的优缺点——优点再多的方法如果用错了地方，就可能会一无是处，缺点再多的方法，如果用对了地方，也会可圈可点。所以，在于你有没有为给定的问题情境找到最适用的方法，而不在于哪个方法的优点较多。 11 青出于蓝——批判与创新的要领（下）制度设计是为了达成某些社会效益，或者解决某些社会弊端，抑或是提升企业的经营效率；它假设我们可以通过制度或政策工具来产出某些社会效益，或者缓抑某些不良的社会现象。因此，制度研究往往会牵涉到一些因果关系的研究。 12 上穷碧落下黄泉——十倍速文献回顾的方法文献回顾第一阶段的流程图（1）用关键字搜寻回顾习型论文，找出最相关的数十篇论文，略读摘要和引言，判断这些文献的相关性和派别。并根据论文后面的参考文献（2）细读各派论文的摘要和引言，标定该派特点的关键性论文；（3）初步确定问题特性表与方法流派，更新关键字，扩大搜寻范围；（4）锁定最相关的一派，略读个论文的论文主题，标定各论文最省力的阅读次序； 13 运筹帷幄——研究工作的策略、进展与风险在完成文献回顾并且产生各种研究的创意之后，接下来必须将他们发展成严谨的研究构想，评估其可行性，并且以备胎方案等手段进行风险控管。筛选、取舍研究创意或构想时，四个关键的原则是：（1）能否产出可被反复检视的确切结论；（2）能否整合成系统性成果，而非零碎的发现，从而提升其严谨度与学术价值；（3）优先评估、发展学术价值较高的论题；（4）避开风险过高或可行性太低的论题； 14 为山九仞——整并补强,巩固战果你的论文最主要的贡献是什么？这个问题可以被分为：你的论文有哪些新颖的贡献？其中最重要的是什么？什么才是好的论文回顾？论文的第一章，必须明确宣告论文的题目与研究的范围，在这个范围内的关键论文，你都必须读过。想要选出最有利的实验条件，就需要理论的预测与引导，或者至少要有言之成理的判断依据，而不能是想当然或碰运气。如果没有理论的引导，用地毯式搜索的方式去求证你要验证的现象，在学术界会被形容为粗暴的手段，因为，他经常是浪费时间与精力，以致事倍功半。 15 掷地有声——学位论文的写作要领每一篇学术论文都是企图向审查委员证明三件事：（1）这篇论文含有原创性的新知识、观点、方法，以有条不紊的方式呈现；（2）这些新颖的知识、观点、方法，对学术界的进步有不可忽视的贡献；（3）他们可以表述为有系统的客观知识，有充分的论据和理论支持，经得起该领域的专家的反复检视。 论文的主要内容就是你的答案或解决方案，他们的假设、前提与适用范围，从各种角度进行反复论证、释疑与答辩，支持这些论点所需要的论据，以及结论。至于那些不具有新颖性或无助于提升学术价值的研究过程、个人的心酸好饿等，都没有必要，甚至不应该写进去。一篇论文通常包含6个主要部分，依序为：摘要、导论或简介、主要理论、研究方法与研究架构、研究结果与分析、讨论与结论和参考文献。每一部分各司其职，严密的整合在一起，有其内在的关系和逻辑。摘要通常只有三五百字，分成二至三段，篇幅尽量在一页以内。你必须用最精准的措辞说出研究主题、研究范围、研究方法，研究的特色与主要的研究成果。 导论或简介 论文的第一章通常是导论或简介，大多分成三个小节，依序为：研究动机与问题背景、文献回顾，以及本研究论题、研究项目与研究成果（贡献）。在第一小节你必须清楚指出，本研究的主题与现实世界有何关系，以及它在学术界的重要性，以便据此彰显这个研究的必要性与价值。接着在第二小节必须回顾与这个研究主题有关的文献，以便据此彰显勾勒出既有知识的的优势与不足处，藉此说明这个研究非可有可无。最后在第三小节陈述你所完成的研究项目和主要成果，作为这一章的结束和结论。通过这样的论述过程，其实你在依次说服读者三件事：（1）第一节旨在宣告这个研究主题很重要；（2）第二节则是在宣告过去的文献确实在这个主题上有所斩获，并逐步扩大，深化成果，但是还留下一大片重要的问题，（3）第三节所描述的研究项目，刚好填补了这个文献的缺口，并且有具体的成果和贡献。 研究主题、项目与成果 文献回顾，先介绍一篇开山之作的主要成就和一项不足，而下一篇文献刚好利用一个新的技术或观点解决了这一项不足，并且留下了另一个关键的问题被第三篇文献用某种新的技术解决，一次类推直到最新的文献，而他所留下的问题刚好是你的研究所要解决的。这样的论述结构好学、好写，而且逻辑清晰、流畅，易读而不易误解——不重要的先谈，重要的留在后头。文献回顾不是流水账正确的论文写作顺序，通常是先从第二章开始写，依序写下去，写完最后一章的结论与建议之后，再回头写第一章，而摘要与论文名称则是留到最后再写。 16 终极秘笈——口试委员的期待（1）你为何要选择这个题目当硕士题目？你的研究动机是什么，陈述这个题目的学术价值或应用价值，自己的兴趣。（2）你如何将一个学术性的问题概念化成一个学术性的问题？你为什么采用采用这个观点、角度或理论模型，去探讨你的原始问题？你有没有想过其他的选择？你如何确定这个选择确实是合理的，甚至是最佳的？你为何选择这个研究范围，而不选择一个更大或更小的研究范围？（3）你是如何发展出这个研究架构？（4）你的研究架构合理吗？有没有任何牵强之处或弱点？（5）你为何要采取这个手段来取得所需要的论据？你为何使用某一种统计方法，而不使用另一种？（6）你如何选择样本，材料或研究范围？（7）你如何产出主要的结论？（8）要如何将你的发现进行更广泛地解读或应用？（9）你的研究对学术界有何贡献？（10）你对自己的研究成果有何意见（批评）？你对以后的研究有何建议？（11）你毕业后有何打算？（12）你还有什么话想说吗？ 硕、博士学位的八大核心能力：（1）创新的能力或对学术界的贡献，有人具体的称他为【知识的跨距】；（2）学术的严谨性与论述的一致性，包括论据拾取，分析、论证与解读过程所呈现的专业性与严谨度，以及论据失去与推论过程的一致性；（3）具有批判精神与策略性思考的方法论能力，包括形塑问题，设计研究架构，并且正确选择研究方法，从批判的角度自我质疑，并将所有的抉择合理化。（4）对于专业知识的掌握能力与理解能力，包括掌握相关文献且活用文献的能力；（5）在有审查的学术期刊或学术会议上，发表其研究结果的可能性，如果能附上已发表的著作清单会更好。（6）分析、批判与客观评价个人研究成果的能力。（7）论文的品质与著作权的理清；（8）口试的表现，尤其是回答问题过程中所展示的独立思考的能力，简洁而切中要点的回答和条理的清晰，以及伴随而来的自信； 17 终生受用——研究能力的活用与转化硕、博士学位的三大能力可以被分为三大部分：（1）主动取得并正确运用专业知识的能力；（2）自我批判与辨别是非的能力；（3）创新的能力；硕、博士真正的核心能力是：【探索未知、明辨是非、推陈出新】研究所得首要学习目标不是知识领域得扩充，而是阅读能力与思想屡次提升。","categories":[{"name":"booking","slug":"booking","permalink":"http://cheertt.top/categories/booking/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://cheertt.top/tags/工具/"}],"keywords":[{"name":"booking","slug":"booking","permalink":"http://cheertt.top/categories/booking/"}]}]}