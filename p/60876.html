<!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="cheerttの个人博客">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.2.3">
    <meta name="root" content="/">
    <link rel="dns-prefetch" href="http://cheertt.top">
    <!--SEO-->

    <meta name="keywords" content="笔记,算法">


    <meta name="description" content="
1 算法的基本概念1、算法的重要性：算法在计算机及软件领域中占有重要地位的一个体现。
2、算法的定义：算法是一个有限的，确定的，具有一定的输入和一些输出的有效过程。
一般认为，算法是由若干条指...">



<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">

    <!--Title-->


<title>算法分析 | cheerttの个人博客</title>


    <link rel="alternate" href="/atom.xml" title="cheerttの个人博客" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
		<script type="text/javascript">
			var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
		</script>
	</div>






    

</head>

</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header"  style="background-image:url(http://puj2izln4.bkt.clouddn.com/banner.jpg?v=6)"  >
    
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://cheertt.top">cheerttの个人博客</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>首页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/AI/"><i class="fa "></i>AI</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/coding/"><i class="fa "></i>Coding</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/Algorithm/"><i class="fa "></i>Algorithm</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/notebook/"><i class="fa "></i>笔记</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/booking/"><i class="fa "></i>读书</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/archives/"><i class="fa "></i>时间轴</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="算法分析">
            
	            算法分析
            
        </h1>
        <div class="post-meta">
    
        <span class="categories-meta fa-wrap">
            <i class="fa fa-folder-open-o"></i>
            <a class="category-link" href="/categories/notebook/">notebook</a>
        </span>
    

    
        <span class="fa-wrap">
            <i class="fa fa-tags"></i>
            <span class="tags-meta">
                
                    <a class="tag-link" href="/tags/笔记/">笔记</a> <a class="tag-link" href="/tags/算法/">算法</a>
                
            </span>
        </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2019/07/28</span>
        </span>
        
            <span class="fa-wrap">
                <i class="fa fa-eye"></i>
                <span id="busuanzi_value_page_pv"></span>
            </span>
        
    
</div>
            
            
    </div>
    
    <div class="post-body post-content">
        <p><img src="http://puj2izln4.bkt.clouddn.com/notebook/suanfafenxi.jpg" alt="彭明辉-研究生手册封面"></p>
<h3 id="1-算法的基本概念"><a href="#1-算法的基本概念" class="headerlink" title="1 算法的基本概念"></a>1 算法的基本概念</h3><p>1、算法的重要性：算法在计算机及软件领域中占有重要地位的一个体现。</p>
<p>2、<strong>算法的定义</strong>：算法是一个有限的，确定的，具有一定的输入和一些输出的有效过程。</p>
<p>一般认为，算法是由若干条指令组成的有穷序列，具有下列五个特征：</p>
<blockquote>
<p>确定性；每条指令都是明确的、无二义的</p>
<p>能行性；每条指令都必须是能够执行的</p>
<p>输入；允许有0个或多个输入量，取自特定的集合</p>
<p>输出；产生一个或多个输出，他们与输入量之间存在某种特定关系</p>
<p>有穷性；每一条指令执行的次数都是有穷的</p>
</blockquote>
<p>有穷指令序列若满足上述5条，则通常称之为<strong>算法</strong>；</p>
<p>只满足前4条而不满足第5条（有穷性）的有穷指令序列通常称之为<strong>计算过程</strong>；</p>
<p>只要不停电、机器不坏，计算过程就可以永远执行下去（死循环）</p>
<p>永远执行的计算过程并非毫无用处——OS就是计算过程</p>
<p>3、算法与其他概念的比较：</p>
<blockquote>
<p>算法：定义一个任务怎样进行的一些步骤；</p>
<p>程序：表示算法的工具；</p>
<p>编程：开发程序的步骤；</p>
<p>软件：程序和算法； </p>
<p>硬件：设备</p>
</blockquote>
<p>4、<strong>算法好坏的衡量尺度</strong>：</p>
<p>最初用计算时间来衡量一个算法的好坏，</p>
<p>但不同的机器之间无法相互比较，需要用独立于计算机的客观衡量标准：①问题的规模；②基本运算；③算法的计算量函数；</p>
<blockquote>
<p>问题的规模：一个或多个整数，作为输入数据量的测度；</p>
<p>基本运算：解决给定问题时占支配地位的运算；</p>
<p><strong>算法的</strong>计算量函数：用问题规模的某个函数来表示算法的基本运算量，这个表示基本运算量的函数称为算法的<strong>时间复杂度</strong>，时间复杂度用T(n)来表示。</p>
</blockquote>
<p>5、渐近时间复杂度：</p>
<p>当问题的规模趋于极限情形时的时间复杂度，表示渐近时间复杂度的三个记号：</p>
<p>T(n)=O(f(n))  给出了算法时间复杂度的上界</p>
<p>T(n)= Ω(f(n)) 给出了算法时间复杂度的下界</p>
<p>T(n)= Θ(f(n)) 既给出了算法时间复杂度的上界，也给出了下界，所以为确界。</p>
<p>6、多项式时间与指数时间的比较：</p>
<p>多项式时间的算法互相之间虽有差距，一般可以接受；</p>
<p>指数量级时间的算法对于较大的n无实用价值</p>
<p>最坏情况时间复杂度：规模为n的所有输入中，基本运算执行次数最多的时间复杂度，</p>
<p>平均情况时间复杂度：规模为n的所有输入的算法时间复杂度的平均值，一般均假设每种输入情况以等概率出现。</p>
<p>7、算法研究的几个重要步骤：①设计；②表示；③确认；④分析；⑤实现和测试</p>
<p><strong>设计</strong>：要根据不同的处理对象设计出高质量的算法；</p>
<p>表示：简明，写出的算法要保证能在计算机上实现</p>
<p>确认：对所有合法的输入，算法要能够得到正确的结果，对所有不合法的输入，算法都要能够正确应对。</p>
<p><strong>分析</strong>：预测算法能在什么样的环境中有效的运行，在最好最坏和平均情况下能够有什么样的复杂度，还需要比较解决同一问题的不同算法各自的优缺点。</p>
<p><strong>实现</strong>和测试：将所给的算法编程实现，通过各种测试来检查所给算法是否正确。</p>
<p> 8、评价算法的主要方面：</p>
<blockquote>
<p>正确性：评价算法的首要因素；程序正确性证明程序测试，即使很小的错误也可能引发巨大的连锁反应，甚至导致严重后果；</p>
<p>健壮性：算法/程序不仅对正确的输入要能计算出正确的结果，对不正确的输入也要能够应对处理；</p>
<p>简单性：算法/程序的可读性好，易调试、改进；</p>
<p>高效性：时间、空间复杂度较小，特别是时间复杂度；</p>
<p>最优性：证明所给算法是解决同一类问题中最好的； </p>
</blockquote>
<p> 9、算法的应用实例：</p>
<blockquote>
<p>Google PageRank</p>
<p>Google Map,Baidu Map</p>
<p>金融领域</p>
</blockquote>
<h3 id="2-递归与分治"><a href="#2-递归与分治" class="headerlink" title="2 递归与分治"></a>2 递归与分治</h3><p>1、排序算法及分析：</p>
<p>插入排序的分析：</p>
<blockquote>
<p>①与输入规模有关；</p>
<p>②与输入序列的特性有关；</p>
</blockquote>
<p>最佳情况运行时间：输入的数组已经排好序；</p>
<p>最坏情况运行时间：问题要求最终按递增的顺序排列，但输入数组按递减顺序排列；O(n2)</p>
<p>解决T(n)=2T(n/2)+cn,其中c&gt;0且c为常量；Θ(nlogn)</p>
<p>在最坏的情况下，归并排序比插入排序好太多。在实践中当n的规模小于30时，不管什么情况，插入排序的性能更好一些。</p>
<p>2、递归的概念：用函数自身给出定义的函数</p>
<p>递归算法：一个算法包含对自身的调用，这种调用可以是直接的，也可以是间接的。</p>
<p>关键是要找到<strong>递归出口</strong>和<strong>递归方程</strong>。</p>
<p>3、整数划分问题：递归举例</p>
<p>将正整数n表示成一系列正整数之和；</p>
<p>正整数n的不同划分个数称为正整数n的划分个数p(n);</p>
<p>目标：求正整数n的不同划分个数p(n)</p>
<p>整数划分问题是递归的一个典型问题，</p>
<p>引入m，将最大加数n1不大于m的划分个数记住q(n,m)</p>
<p>当n=m=1时，q(n,m)=1;</p>
<p>当n&lt;m时，q(n,m)=q(n,n);</p>
<p>当n=m&gt;1时，1+q(n,n-1);</p>
<p>当n&gt;m&gt;1时，q(n,m-1)+q(n-m,m) </p>
<blockquote>
<p>n=n1+n2+n3+…+nk;n1&gt;=n2&gt;=n3&gt;=n4&gt;=…&gt;=nk&gt;=1,k&gt;=1</p>
<p>当n1=m时，n’=n-m,即q(n-m,m)</p>
<p>当n1&lt;m时，q(n,m-1)</p>
</blockquote>
<p>4、汉诺塔问题</p>
<p>分析：n=1时，直接a-&gt;b</p>
<p>n&gt;1时，借助c实现移动，可先将n-1个圆盘按照规则a-&gt;c,再将大圆盘a-&gt;b,最后将n-1个圆盘c-&gt;b</p>
<p>可以通过递归实现。</p>
<p>5、递归的概念非常重要：</p>
<p>优点：结构清晰，可读性强，而且容易用数学归纳法来证明算法的正确性，为设计算法、调试程序带来很大的便利；</p>
<p>缺点：递归算法的运行效率较低；</p>
<p>递归式：当一个算法包含对自身的递归调用时，其运行时间通常可以用递归式来表示。</p>
<p>T(n)=2T(n/2)+Θ(n) 当n&gt;1时，T(n)=Θ(n) 当n=1时。</p>
<p><strong>6、递归式的解法：</strong></p>
<blockquote>
<p>代换法（预测）；</p>
<p>递归树方法；</p>
<p>主方法；</p>
</blockquote>
<p> (1) 代换法：</p>
<p>步骤：①猜测解的形式；②用数学归纳法证明之；</p>
<p>只适用于解的形式很容易猜的情形；</p>
<p>如何猜测需要靠经验；</p>
<p>T(n)=2T(n/2)+n  T(n)=O(nlogn)</p>
<p>T(n)=2T(n/2 + 17)+n  T(n)=O(nlogn)</p>
<p>T(n)=T(n/2)+1  T(n)=O(logn)</p>
<p>(2) 递归树方法：</p>
<p>①每一个节点代表递归函数调用集合中一个子问题的代价，将所有层的代价相加得到总代价；</p>
<p>②当用递归式表示算法的时间复杂度时，可用递归树的方法；</p>
<p>③递归树方法模拟了算法的递归执行，可以由递归树方法产生对算法时间复杂度的较好猜测；</p>
<p>(3) 主方法：</p>
<p>T(n)=aT(n/b)+f(n);a&gt;=1,b&gt;1,a,b均为常数，f(n)是渐近正函数。</p>
<p>a表示子问题的个数，n/b表示问题的规模，f(n)表示分解和合并的代价；</p>
<blockquote>
<p>f(n)&lt;n^logba ,T(n)=Θ(n^logba)</p>
<p>f(n)=n^logba ,T(n)=Θ(lgn x n^logba)</p>
<p>f(n)&gt;n^logba ,T(n)=Θ(f(n))</p>
</blockquote>
<p>注意，上述三种情况没有覆盖所有的f(n)</p>
<p><strong>7、分治法的基本策略/步骤：</strong></p>
<p>分解：将原问题分解为子问题；</p>
<p>解决：求解子问题；</p>
<p>合并：组合子问题的解得到原问题的解；</p>
<p><strong>8、分治法的使用条件：</strong></p>
<p>适合分治法求解的问题一般具有以下特征：</p>
<blockquote>
<p>① 问题的规模缩小到一定程度就可以容易的解决；</p>
<p>② 问题可以分解成若干个规模较小的相同问题，即该问题具有最优子结构性质；</p>
<p>③ 基于子问题的解可以合并为原问题的解；</p>
<p>④ 问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题；</p>
</blockquote>
<p><strong>9、对平衡的理解：</strong></p>
<blockquote>
<p>使子问题规模尽量接近的做法，就是平衡；</p>
<p>在使用分治法和递归时，要尽量把问题分成规模相等，或至少规模相近的子问题，以提高算法的效率；</p>
</blockquote>
<p>是不是规模相等或者规模相差无几才算平衡？不是的。</p>
<p>10、分治法实例：</p>
<p>(1) a^n</p>
<p>(2) 快速排序</p>
<p>快速排序最坏时间复杂度Θ(n2),平均情况时间复杂度Θ(nlgn);</p>
<p>快速排序的随机化版本——主要区别在于主元的选择，不总是选择A[r]作为主元，而是从A[p…r]中随机选择一个元素作为主元。</p>
<p>快排通常是用于排序的最佳使用选择；</p>
<p>原地排序，在虚拟环境中也能很好的工作；</p>
<p>(3) Fibonacci数列：自底向上，依次计算</p>
<p>(4) 矩阵乘法，直接分治的时间复杂度并不比直接计算好；Strassen的策略-只需要7次子矩阵的乘法；</p>
<p>(5) 最大元、最小元：</p>
<p>给定n个数据元素，找出其中的最大元和最小元；</p>
<blockquote>
<p>① 当n=2时，一次比较就可以找出两个数据元素的最大元和最小元；</p>
<p>② 当n&gt;2时，可以把n个数据元素分为大致相等的两半；</p>
</blockquote>
<p>① 直接解法：逐个找，用n-1次比较找出最大元，用n-2次比较找出最小元，比较次数(基本运算)为2n-3次；</p>
<p>② 分治法：3n/2-2</p>
<p>(6) 最近点对：</p>
<p>对于平面上给定的n个点，给出距离最近的两个点；</p>
<p>分解：对所有点按照x坐标从小到大排序，根据下标进行分割，使得点集分成两个集合；</p>
<p>解决：递归寻求PL和PR中的最近点对，设其找到的最近点对的距离分别是OL和OR，置O=min(OL,OR)</p>
<p>合并：可能并不是O，存在这样的情况，一个点在PL中，另一个点在PR中，而且这两点之间的距离小于O，如何检查？只考虑分割线两侧各为O的点，继续压缩点的范围。</p>
<p>难点：如何在线性时间内获得，有论文证明，在这一片狭小区域，最多只包含7个点。</p>
<p>时间复杂度：O(nlogn)</p>
<blockquote>
<p>① 预处理  将点对按X坐标排序；将点对按Y左边排序；</p>
<p>② 分解  按照X坐标将点集二分，同时获得分解后的已按Y坐标排好序的点集；</p>
<p>③ 递归求解</p>
<p>④ 合并  找出带状区域中的点；检查带状区域中的点（已排序），计算每点与其后面7个点的距离，更新最近点对距离。</p>
</blockquote>
<p>(7) 寻找顺序统计量问题：</p>
<p>求第i小元素问题、选择问题，设集合S中共有n个数据元素，要在S中找到第i小元素；</p>
<p>最小元：第一个顺序统计量；</p>
<p>最大元：第n个顺序统计量；</p>
<p>中位数：i=[(n+1)/2]</p>
<p>① 排序：合并排序，堆排序；</p>
<p>② 期望线性时间：</p>
<p>一般情况T(n)=T(9n/10)+Θ(n)=Θ(n);    </p>
<p>最坏情况T(n)=T(n-1)+Θ(n)=Θ(n2);</p>
<p>期望线性时间的求解方法，在平均情况下，任何顺序统计量问题都可以在线性时间内得到；</p>
<blockquote>
<p>① 使用random partition对数组进行划分；</p>
<p>② 检查主元元素是否第i小，如果是，则返回；</p>
<p>③ 否则，确定第i小落在划分后的低区还是高区；</p>
<p>④ 如果落在低区，则在低区的子数组中递归选择；</p>
<p>⑤ 如果落在高区，则在高区的子数组中递归选择；</p>
</blockquote>
<p>③     最坏情况线性时间：</p>
<p>基本思想：保证对数组的划分是好的划分，</p>
<p>③ 最坏情况线性时间：</p>
<p><strong>11、分治法的基本思想：</strong></p>
<p>① 最为常用的算法技术；</p>
<p>② 分治法的基本思想是将一个规模较大的问题分解为若干个规模较小的子问题，<strong>子问题相互独立且与原问题同类</strong>；</p>
<p>③ 求解时，首先求出这些子问题的解，然后把子问题的解组合起来就可得到原问题的解；</p>
<p>12、分支算法分析：</p>
<p>当算法包含对其自身的递归调用时，其时间复杂度通常可用递归式来表示；</p>
<p>分支与递归往往联系在一起；</p>
<p>对于递归式：可以由①代换法；②递归树法；③主方法；</p>
<h3 id="3-动态规划"><a href="#3-动态规划" class="headerlink" title="3 动态规划"></a>3 动态规划</h3><p>分治法求解回顾：子问题相互独立，不包含公共子问题。<br>动态规划与分治法类似，也是将问题分解为规模逐渐减小的同类型的子问题；与分治法不同的是，分解所得的子问题都是重复的。</p>
<p>动态规划相关的重要概念：<br>（1）子问题的高度重复性；<br>（2）最优子结构性质：问题的最优解中包含着其每一个子问题的最优解；</p>
<p>适合用动态规划方法求解的问题：<br>（1）若一个问题可以分解为若干个高度重复的子问题，且问题也具有最有子结构性质，就可以用动态规划求解；<br>（2）具体方式：可以递推的方式逐层计算最优值并记录必要的信息，最后根据记录的信息构造最优解。</p>
<p>动态规划的总体思想：<br>保存已解决的子问题的答案，在需要时使用，从而避免大量重复计算。</p>
<p>动态规划方法解题步骤：<br>（1）找出最优解的性质，并刻画其结构特征；<br>（2）递归地定义最优值（写出动态规划方程）；<br>（3）以自底向上地递推方式计算出最优值；<br>（4）根据计算最优值时得到地信息，以递归方法构造一个最优解；</p>
<h3 id="4-贪心算法"><a href="#4-贪心算法" class="headerlink" title="4 贪心算法"></a>4 贪心算法</h3><p>1、贪心算法的基本思想：</p>
<p>① 适用于求解<strong>最优化问题</strong>的算法往往包含一些列步骤，每一步都有一组选择；</p>
<p>② 贪心算法总是做出在<strong>当前看来是最好的选择</strong>；</p>
<p>③ 贪心算法并不从整体最优上加以考虑，它所做出的选择只是在某种意义上的<strong>局部最优选择</strong>；</p>
<p>④ <strong>贪心算法不能对所有问题都得到整体最优解，但对许多问题它能产生整体最优解</strong>；</p>
<p>⑤ 在一些情况下，即使贪心算法不能得到整体最优解，其最终结果是<strong>对最优解很好的近似</strong>；</p>
<p>⑥ 与动态规划相比，贪心算法更<strong>简单</strong>，更<strong>直接</strong>；</p>
<p>2、活动安排问题：</p>
<p>目标：要在所给的活动集合中选出最大的相容活动子集合，尽可能多的活动；</p>
<p>复杂度分析：如果已经排序，算法的时间复杂度为Θ(n),如果事先没有按照结束时间增序排列，排序需O(nlgn)</p>
<p>贪心算法可以获得该问题的整体最优解。证明：①活动安排问题有一个最优解以贪心选择开始；②做出贪心选择之后，原问题简化为比原问题更小的但与原问题形式相同的子问题。</p>
<p>3、贪心算法的基本要素：</p>
<p>① 贪心算法通过做出一系列的选择来给出某一问题的最优解。它所作出的每一个选择当前状态下的最好选择(局部)，即贪心选择；</p>
<p>② 这种贪心选择并不总能产生最优解，但对于一些问题，比如活动安排问题，可以给出最优解；</p>
<p>③ 许多可以用贪心算法求解的问题，具备以下<strong>两个性质</strong>：(1) 贪心选择性质；(2) 最优子结构性质；</p>
<p>4、设计贪心算法的步骤：</p>
<p>① 将最优化问题转化，先做出选择，再解决剩下的一个子问题；</p>
<p>② 证明原问题总有一个最优解是做贪心选择得到的，从而说明贪心选择的安全；</p>
<p>③ 说明在做出贪心选择之后，子问题的最优解与所做出的贪心选择联合起来，可以得出原问题的一个最优解；</p>
<p>5、贪心选择性质：</p>
<p>① 是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到；</p>
<p>② 这是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别；</p>
<p>③ 动态规划通常以自底向上的方式求解各个子问题；</p>
<p>④ 贪心算法则通常以自顶向下的方式进行，以迭代的方式做出    相继的贪心选择，没做一次贪心选择就将所求问题简化为规模更小的子问题；</p>
<p>6、最优子结构性质：</p>
<p>① 当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质；</p>
<p>② 问题的<strong>最优子结构性质</strong>是该问题可用动态规划算法或贪心算法求解的关键特征；</p>
<p>7、最优装载问题：</p>
<p>① 最优装载问题可用贪心算法求解；</p>
<p>② 采用重量<strong>最轻者先装</strong>的贪心选择策略，可产生最优装载问题的最优解；</p>
<p>8、贪心算法的重要实例：</p>
<p>(1) 单源最短路径——Dijkstra算法</p>
<p>求某一点到所有其他各顶点的最短路长度；</p>
<p>设u是G的某一个顶点，把从源到u且中间只经过S中顶点的路称为从源到u的特殊路径，并用数组dist记录当前每个顶点所对应的最短特殊路径长度。</p>
<p><strong>因为Dijkstra算法总是在V-S中选择”最近”(具有最短特殊路径长度)的顶点，所以说Dijkstra算法使用了贪心策略。</strong></p>
<p><strong>贪心策略体现在对V-S中的点的选择上。</strong></p>
<p>对于具有n个顶点和e条边的带权有向图，如果用带权邻接矩阵表示这个图，O(n2)</p>
<p>(2) 最小生成树</p>
<p>在G的所有生成树中，耗费最小的生成树称为G的最小生成树。</p>
<p>网络中的最小生成树在实际中有广泛的应用，最小生成树给出了建立通信网络的最经济的方案。</p>
<p>① Prim算法 O(n2)</p>
<p>② Kruskal算法 从小到大排序，依次选择，判无环路；</p>
<p>贪心策略：将图中的边按权值从小到大排序，由小到大顺序选取各条边，若选某边后不形成回路，将将其保留作为输的一条边。</p>
<p>(3) Huffman编码</p>
<p>一种可变长编码，广泛应用于数据文件的压缩；</p>
<p>Huffman算法以自底向上的方式构造表示最优前缀码的二叉树T。</p>
<p>贪心策略：每次都选择根节点”频率”值最小的两棵树合并。</p>
<h3 id="5-随机算法"><a href="#5-随机算法" class="headerlink" title="5 随机算法"></a>5 随机算法</h3><p>1、随机数：</p>
<p>概率相等(均匀随机)，不可预测，不可重现；</p>
<p>在目前的计算机中，无法产生真正的随机数，因此在随机算法中使用随机数都是一定程度上随机的，即伪随机数。产生为随机数的方法：线性同余法；</p>
<p>2、确定性算法：</p>
<p>若输入确定，则对这个特定的输入的每次的运行过程是可重复的，运行结果是一样的；</p>
<p>3、随机算法的基本思想：</p>
<p>① 引入了随机因素；</p>
<p>② 在随机算法中，不要求算法对所有可能的输入均正确计算，只要求出现错误的可能性小到可以忽略的程度；</p>
<p>③ 另外，也不要求对同一输入，算法每次执行时给出相同的结果；</p>
<p>4、随机算法的特点：</p>
<p>有不少问题，目前只有效率很差的确定性求解算法，但用随机算法取求解，可以很快的获得相当可信的结果；</p>
<p>5、随机算法的应用领域：</p>
<p>随机算法在分布式计算、通信、信息检索、计算几何、密码学等许多领域都有着广泛的应用；</p>
<p>最著名的是在公开密钥体系，RSA算法方面的应用。</p>
<p>6、随机算法的分类：</p>
<p>通常分为两类：Las Vegas算法和Monte Carlo算法</p>
<p>(1) Las Vegas算法：</p>
<p>在少数应用中，<strong>可能出现求不出解</strong>的情况，但<strong>一旦找到一个解，这个解一定是正确的</strong>，在求不出解时，需再次调用算法进行计算，直到获得解为止，对于此类算法，主要是分析算法的时间复杂度的期望值，以及调用一次产生失败(求不出解)的概率。</p>
<p>(2) Monte Carlo算法：</p>
<p>通常<strong>不能保证计算出来的结果总是正确</strong>的，一般只能断定所给解的正确性不小于p(1/2&lt;p&lt;1);</p>
<p>通过算法的反复执行(即以增大算法的执行时间为代价)，能够使发生错误的概率小到可以忽略的程度；</p>
<p>由于每次执行的算法是独立地，故k次执行均发生错误的概率为(1-p)^k;</p>
<p>对于判定问题(只能回答”yes”或”no”)，带双错的：回答”yes”或”no”都可能错；</p>
<p>带单错的，只有一种回答可能错；</p>
<p>Las Vegas算法可以看成是单错概率为0的Monte Carlo算法；</p>
<p>7、两类随机算法的应用场景：</p>
<p>使用时，选择哪一类随机算法，到底哪一种随机算法好呢？依赖于应用。</p>
<p>在不允许发生错误的应用中(人造飞船、电网控制等)，Monte Carlo算法不可以使用；</p>
<p>若小概率的出错允许的话，Monte Carlo算法比Las Vegas算法要节省许多时间，是人们常常采用的方法；</p>
<p>8、随机算法的优点：</p>
<p>① 对于某一给定的问题，随机算法所需的时间与空间复杂性，往往比当前已知的、最好的确定性算法要好；</p>
<p>② 到目前为止设计出来的各种随机算法，无论是从理解上还是实现上，都是极为简单的；</p>
<p>③ 随机算法避免了去构造最坏情况的例子；</p>
<p>9、找第k小元素的随机算法(Las Vegas算法)：</p>
<p>在n个数中随机找一个数A[i]=x,然后将其余n-1个数与x比较，分别放入三个数组中：S1(元素均&lt;x)、S2(元素均=x)、S3(元素均&gt;x)</p>
<p>若|S1|&gt;=k,则调用Select(k,S1);</p>
<p>若(|S1|+|S2|)&gt;=k,则第k小元素就是x;</p>
<p>否则就有(|S1|+|S2|)&lt;k,此时调用Select(k-|S1|-|S2|,S3)</p>
<p>定理：若以等概率方法在n个数中随机取数，则该算法用到的比较数的期望值不超过4n;</p>
<p>说明：如果假定n个数互不相同，如果有相同的数的话，落在S2中的可能性会更大，比较数的期望值会更小一些；</p>
<p>10、Sherwood随机化方法：(属Las Vega算法)：</p>
<p>如果某个问题已经有了一个平均情况下较好的确定性算法，但是该算法在最坏情况下效率不高，此时引入一个随机数发生器，可将一个确定性算法，改成随机算法，使得对于任何输入实例，该算法在概率意义下都有很好的性能（Select、Quicksort）</p>
<p>如果算法(所给的确定性算法)无法直接使用Sherwood方法，则可以采用随机预处理的方法，使得输入对象服从均匀分布(或者其他分布)，然后再用确定性算法对其进行处理。所得效果在概率意义下与Sherwood型算法相同。</p>
<p>Sherwood算法总能求得问题的一个解，且所求得的解是正确的；</p>
<p>当一个确定性算法在最坏情况和平均情况下的时间复杂度有较大差别时，可在确定性算法中引入随机性将其改造成Sherwood算法，以消除或减少问题的好坏输入实例间的差别。</p>
<p>11、Testing String Equality:</p>
<p>设A处有一个长字符串x，B处也有一个长字符串y，A将x发给B，由B判断是否由x=y;</p>
<blockquote>
<p>① 首先由A发一个x的长度给B，若长度不等，则x≠y;</p>
<p>② 若长度相等，则采用“取指纹”的方法；</p>
<p>A对x进行处理，取出x的“指纹”，然后将x的指纹发给B；由B检查x的指纹是否等于y的指纹；若取k次指纹(每次取法不同),每次两者结果均相同，则认为x与y是相等的；随着k的增大，误判率可趋于0；</p>
</blockquote>
<p>常用的指纹：</p>
<p>令I(x)是x的编码，取Ip(x)=I(x)(mod p)作为x的指纹；</p>
<p>这里的p是一个小于M的素数，M可根据具体需要调整；</p>
<p>12、Pattern Matching(Monte Carlo算法)</p>
<p>给定两个字符串，X=x1,x2,…,xn,Y=y1,y2,…,ym,判断Y是否为X中的一段；</p>
<p>① 可用KMP算法在O(m+n)时间内获得结果，但算法较为繁琐。</p>
<p>② 考虑用随机算法，暴力求解；</p>
<blockquote>
<p>记X(j)=xj xj+1 … xj+m-1(从X的第j位开始，长度与Y一样的子串)</p>
<p>从起始位置j=1开始到j=n-m+1,逐一比较X(j)的指纹Ip(X(j))与Y的指纹Ip(Y)</p>
<p>由于Ip(X(j+1))可以很方便地根据Ip(X(j))计算出来，故算法可以很快完成；    </p>
</blockquote>
<p>最终算法复杂度为O(m+n)</p>
<p>该算法可以改造成Las Vegas算法，在Ip(Y)=Ip(X(j))时，不直接return j,而去比较Y和X(j)</p>
<p>13、Random Sampling问题</p>
<p>从n个元素中随机取m个数</p>
<blockquote>
<p>Las Vegas算法，用一个长为n的布尔数组B来标识i是否被选中；初始时均表为“未选中”；然后随机产生[1,n]之间的一个整数，若B[i]为“未选中”，则将i加入被选中队列，同时把B[i]标识为“已选中”；反复执行，直到m个不同的数全部被选出为止；</p>
</blockquote>
<p>上述算法存在问题，当n和m比较接近的时候，产生最后几个随机数的时间可能很长(有95%以上的可能性是已选中的数)，</p>
<blockquote>
<p>改进方法：当m&gt;n/2时，先去生成(n-m)(&lt;n/2)个随机数，然后再取剩下的m个数作为选出的数；</p>
</blockquote>
<p>上述算法存在的问题：① 当n与m相比大很多时(n&gt;m2)，布尔数组对空间浪费很多；</p>
<blockquote>
<p>改进：用一个允许冲突的、长为m的散列表来存放随机数；产生一个数后，看其是否在散列表中，若不在则加入，若已在则抛弃该数，再去产生下一个数；</p>
</blockquote>
<p>时间复杂度T(n)=Θ(n)</p>
<p>14、主元素问题</p>
<p>n个元素的数组中，某一元素个数超过一半，则该元素称为主元素；</p>
<p>对于给定数组T，判断T数组是否含有主元素；</p>
<blockquote>
<p>Mente Carlo算法：</p>
<p>每次随机选一个数，判断其在数组中是否存在；</p>
<p>计算时间和调用次数相关；</p>
</blockquote>
<p>15、素数测试问题</p>
<p>判断一个数是否是是素数；</p>
<p>费尔马小定理：若n为素数，且0&lt;a&lt;n，有a^(n-1) mod n=1,即Fermat条件a^(n-1) mod n≠1则必为合数；</p>
<p>逆定理不成立，但反例不多，特别是当n很大且是随机选取的时候；</p>
<p>16、素数判定方法</p>
<blockquote>
<p>直接用Fermat条件2^(n-1) mod n =1来判断n是否为素数；</p>
<p>此时，若算法的回答是“合数”，则100%正确；</p>
<p>若算法的回答是“素数”，则出错的概率很小（带单错）;</p>
<p>当n不太大时，满足条件2^(n-1) mod n =1的合数n不多;</p>
<p>能否对其他的a取测试是否有a^(n-1) mod n =1,从而再排除一些满足条件2^(n-1) mod n =1的合数；</p>
<p>回答是：可以排除一些，但不能完全排除；</p>
<p>满足Fermat条件的数未必全是素数；</p>
<p>有些合数也满足Fermat条件，这些合数被称为Carmichael数；</p>
</blockquote>
<p>二次探测定理：如果p是一个素数，且0&lt;x&lt;p,则方程x^2 mod p = 1的解为x=1,p-1</p>
<p>利用二次探测定理，可以在基于Fermat条件判断时，增加二次探测，一旦违背二次探测条件，则可得出不是素数的结论。</p>
<p>17、n后问题</p>
<p>对于n后问题的任何一个解而言，每一个皇后在棋盘上的位置无任何规律，不具有系统性，而更像是随机放置的；</p>
<p>Las Vegas算法：</p>
<p>在棋盘上相继的各行中随机地放置皇后，并注意使新放置的皇后与已放置的皇后互不攻击，直至n个皇后均已相容的放置好，或已没有下一个皇后的可放置位置时为止。</p>
<p>如果将上述随机放置策略与回溯法相结合，可能会获得更好的效果。</p>
<blockquote>
<p>可以现在棋盘上的若干行中随机地放置皇后；</p>
<p>然后在后继行中用回溯法继续放置，直至找到一个解或宣告失败；</p>
<p>随机放置的皇后越多，后继回溯搜索所需的时间就越少，但失败的概率也就越大</p>
</blockquote>
<p>n后问题变为针对8皇后问题：</p>
<p>随机放两个皇后，再回溯比完全用回溯快大约两倍；</p>
<p>随机放三个皇后，再回溯比完全用回溯快大约一倍；</p>
<p>随机放所有皇后，再回溯比完全用回溯慢大约一倍；</p>
<p>主要由产生随机数所需的时间导致。</p>
<h3 id="6-回溯法"><a href="#6-回溯法" class="headerlink" title="6 回溯法"></a>6 回溯法</h3><p>图的表示——邻接表和邻接矩阵；</p>
<p>广度优先搜索（BFS）</p>
<p>深度优先搜索（DFS）尽可能深的搜索一个图</p>
<p>1、回溯法：<br>有许多问题，当需要找出它的解集或者要求在某些约束条件下的最优解时，往往可以用回溯法；</p>
<p>回溯法的基本做法是搜索，他是一只可以避免不必要搜索的穷举式搜索法，</p>
<p>回溯法用于求解一些组合数较大的问题；</p>
<p>2、回溯法的基本思想：</p>
<p>回溯法在问题的解空间树中，按<strong>深度优先</strong>策略，从根节点出发搜索解空间树；</p>
<p>算法搜索至解空间树的任意一点时，先判断该节点是否包含问题的解；</p>
<p>如果肯定不包含，则跳过对该节点为根的子树的搜索，逐层向其祖先节点回溯；</p>
<p>否则，进入该子树，继续按深度优先策略搜索；</p>
<p>3、问题的解空间：</p>
<p>问题的<strong>解向量</strong>：回溯法希望一个问题的解能够表示成一个n元式(x1,x2,…,xn)的形式；</p>
<p>显<strong>约束</strong>：对分量xi的取值限定；</p>
<p>隐<strong>约束</strong>：为满足问题的解而对不同分量之间施加的约束；</p>
<p><strong>解空间</strong>：对于问题的一个实例，解向量满足显式约束条件的所有多元组，构成了该实例的一个解空间；</p>
<p>通常将解空间组织成树或者图的形式；</p>
<blockquote>
<p>问题的解空间一般用解空间树的方式组织；</p>
<p>树的根节点位于第一层，表示搜索的初试状态；</p>
<p>第二层的节点表示对解向量的第一个分量做出选择后达到的状态；</p>
<p>第一层到第二层的边上标出对第一个分量选择的结果；</p>
<p>依次类推，从树的根节点到叶子结点的路径就构成了解空间的一个可能解；</p>
</blockquote>
<p>4、生成问题状态的说明：</p>
<p>扩展节点：一个正在产生儿子的节点被称为扩展节点；</p>
<p>活节点：一个自身已生成但其儿子还没有全部生成的节点称作活节点；</p>
<p>死节点：一个所有儿子已经产生的节点称作死节点；</p>
<p>生成问题状态的基本方法——DFS</p>
<p>生成问题状态的基本方法——回溯法</p>
<p>为了避免生成那些不可能产生最优解的问题状态，要不断利用限界函数处死那些不可能产生所需解的活节点，从而减少问题的计算量；</p>
<p>具有限界函数的深度优先生成法称为<strong>回溯法</strong>。</p>
<p>5、回溯法的基本思想：</p>
<p>(1) 针对所给问题，定义问题的解空间；</p>
<p>复杂问题常有很多可能解，这些解构成解空间，确定正确的解空间很重要。</p>
<p>(2) 确定易于搜索的解空间结构；</p>
<p>(3) 以深度优先方式搜索解空间，并在搜索过程中用剪枝避免无效搜索；</p>
<p>(4) 常用剪枝函数：用约束函数在扩展节点处减去不满足约束的子树，用限界函数减去得不到最优解的子树；</p>
<p>在搜索至树上任意一点时，先判断该节点对应部分解是否满足约束条件，或是否超出目标函数的界：</p>
<p>判断该节点是否包含问题的(最优)解：</p>
<blockquote>
<p>不包含，则跳过对以该节点为根的子树的搜索，剪枝；</p>
<p>包含，则进入以该节点为根的子树，继续按深度优先搜索；</p>
</blockquote>
<p>回溯法的搜索过程涉及的节点(搜索空间)只是整个解空间树的一部分，搜索时，常用两种策略避免无效搜索(剪枝函数)</p>
<blockquote>
<p>用约束条件减去得不到可行解的子树；</p>
<p>用目标函数减去得不到最优解的子树；</p>
</blockquote>
<p>用回溯法解题的一个显著特征是在搜索过程中动态产生问题的解空间。在任何时刻，算法只保存从根节点到当前扩展节点的路径。</p>
<p>回溯法对解空间作深度优先搜索，因此，在一般情况下用递归方法实现回溯法。</p>
<p>采用树的非递归深度优先遍历算法，可将回溯法表示为一个非递归迭代过程。</p>
<p>6、回溯法求解时常见的两类解空间树：</p>
<p>(1) <strong>子集树</strong>：当所给问题是从n个元素的集合S中找出S满足某种性质的子集时，相应的解空间树称为子集树；O(2^n)</p>
<p>(2) <strong>排列树</strong>：当所给问题是确定n个元素满足某种性质的排列时，相应的解空间树称为排列树；O(n!)</p>
<p>7、装载问题：（子集树）</p>
<p>8、批处理作业调度：</p>
<p>批处理作业调度问题要求对于给定的n个作业，制定最佳作业调度方案，使其完成时间和达到最小。</p>
<p>9、符号三角形：O(n2^n)</p>
<p>10、n后问题：</p>
<p>11、0-1背包：（子集树）</p>
<p>12、图的m着色问题：优化问题、O(nm^n)</p>
<p>给定无向图G和m中不同颜色，用这些颜色为图G的各顶点着色，每个顶点着一种颜色。是否有一种着色方法使G中每条边的2个顶点着不同的颜色？</p>
<p>可行性约束函数：顶点i与已着色的相邻顶点颜色不重复；</p>
<p>问题的解空间：高度为n+1的完全m叉树</p>
<p>13、旅行售货员问题：O(n!) （排列树）</p>
<p>14、圆排列问题：O((n+1)!)  </p>
<p>给定一个大小不等的圆c1,c2,…,cn,现要将这n个圆排进一个矩形框中，且要求各圆与矩形框相切。</p>
<p>圆排列问题要求从n个圆的所有排列中找出最小长度的圆排列；</p>
<h3 id="7-分支限界法"><a href="#7-分支限界法" class="headerlink" title="7 分支限界法"></a>7 分支限界法</h3><p>1、分支限界法和回溯法的异同：</p>
<p>① 分支限界法类似于回溯法，是在问题的解空间树上搜索问题解的算法；</p>
<p>② 回溯法的求解目标是找出解空间树中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出在某种意义下的最优解；</p>
<p>搜索方式不同：<strong>回溯法以深度优先</strong>的方式搜索解空间树，而<strong>分支限界法以广度优先</strong>或以最小耗费优先的方式搜索解空间树。</p>
<p>2、分支限界法的基本思想：</p>
<p>分支限界法以广度优先或最小耗费优先的方式搜索问题的解空间树。</p>
<p>在分支限界法中，每一个活节点只有一次机会成为扩展节点。活节点一旦成为扩展节点，就一次性产生其所有儿子节点。在这些儿子节点中，导致不可行解或导致非最优解的儿子节点被舍弃，其余儿子节点被加入或节点列表中。</p>
<p>此后，从活节点表中取下一个节点成为当前扩展节点，并重复上述节点扩展过程。这个过程一直持续到找到所需的解或活节点表为空时为止。</p>
<p>3、常见的两种分支限界法：<br>(1) 队列式(FIFO)分支限界法：按照队列先进先出(FIFO)原则选取下一个节点为扩展节点；</p>
<p>(2) 优先队列式分支限界法：按照优先队列中规定的优先级选取优先级最高的节点成为当前的扩展节点；</p>
<p>应用优先队列式分支限界法求解具体问题时，应该根据具体问题的特点确定选用最大优先队列或者最小优先队列或者最小优先队列表示解空间的活节点表；</p>
<p>4、装载问题：</p>
<p>如果一个给定装载问题有解，则采用下面的策略可得到最优装载方案；</p>
<p>首先将第一艘轮船尽可能装满，将剩余的集装箱装上第二艘轮船；</p>
<p>优先队列式分支限界法：<br>解装载问题的优先队列式分支限界法用最大优先队列存储活节点表。活节点x在优先队列中的优先级定义为从根节点到节点x的路径所相应的载重量再加上剩余集装箱的重量之和；</p>
<p>优先队列中优先级最大的活节点称为下一个扩展节点，以节点x为根的子树中所有节点相应的路径的载重量不超过它的优先级。子集树中叶节点所相应的载重量与其优先级相同。</p>
<p>在优先队列式分支限界法中，一旦有一个叶节点称为当前扩展节点，则可以断言该叶节点所相应的解即为最优解，此时可终止算法。</p>
<p>5、0-1售货问题：</p>
<p>6、旅行售货员问题：排列树</p>
<h3 id="8-NP完全理论"><a href="#8-NP完全理论" class="headerlink" title="8 NP完全理论"></a>8 NP完全理论</h3><p>对于N个盘子的问题，如果使用递归进行求解，需要2^n-1次移动；</p>
<p>多项式时间：排序：O(nlgn)、有序查找：O(lgn)、最大、最小元：O(n)；</p>
<p>非多项式时间：旅行商问题：O(n^2 2^n)、背包问题：O(2^(n/2))；</p>
<p>将计算问题转化成语言</p>
<p>复杂性的度量，耗费的时间，耗费的存储。</p>
<p>1、计算的模型——自动机理论：</p>
<p>① 有限自动机(FA):存储量极小的计算机，在文本处理，编译程序及硬件设计中有应用；</p>
<p>② 下推自动机(PDA):带有一个栈的计算机，在程序设计语言和人工智能中有应用；</p>
<p>③ 图灵机(TM):有无限可改写存储的计算机，能解决实际计算机可以解决的一切问题；</p>
<p>FA和FDA是简化的图灵机，<strong>一般以图灵机作为计算的理论模型</strong>；</p>
<p>2、P与NP问题是否相等：</p>
<p>P问题是<strong>容易解决</strong>的问题，NP问题是<strong>容易验证</strong>的问题，P是属于NP的，但是严格相等还是真包含我们不得而知，他是21世纪最大难题，主要应用在密码学，解码和编码；</p>
<p>3、计算模型：</p>
<p>计算模型是计算机科学的重要组成部分；</p>
<p>NPC的原始定义需要借助非确定性图灵机等计算模型的概念；</p>
<p>计算模型中有不少好的思想可供借鉴；</p>
<blockquote>
<p>RAM、RASP、确定性Turing机、非确定性Turing机</p>
</blockquote>
<p>(1) 一个RAM程序定义了输入带到输出带的一个映射；</p>
<p>(2) RASP的整体结构类似于RAM，所不同的是RASP的程序是存储在寄存器中的。</p>
<p>(3) 凡是Turing机可以计算的问题就是可计算的，否则就是不可计算的。</p>
<p>任何合理的计算模型都是相互等价的(计算范围相同)；</p>
<p>合理：单位时间内可以完成的工作量，有一个多项式的上限；</p>
<p>与RAM模型类似，图灵机既可以作为语言接收器，也可作为计算函数的装置；</p>
<p>4、非确定性Turing机：</p>
<p>一般来说，将可由多项式时间算法求解的问题看做是易处理的问题，而将需要超多项式时间才能求解的问题看做是难处理的问题；</p>
<p>在非确定性图灵机计算模型(NDTM)下，许多问题可以在多项式时间内求解；</p>
<p>5、P类与NP类语言：</p>
<p>P：能在多项式时间内被一台图灵机所接受的语言；</p>
<p>NP：能在多项式时间内被一台NDTM所接受的语言；</p>
<p>NPC：属于NP问题中比较难解的问题；</p>
<p>6、最优化问题和判定问题：</p>
<p>判定问题：回答”yes”或”no”;</p>
<p>最优化问题：可以与一个判定问题相对应；</p>
<p>7、证书：</p>
<p>若集合S包含判定问题A的所有解，则称S是A的证书集，S中的元素称为A的一个证书（注意，证书不一定是解）;</p>
<p>Hamilton路径问题：</p>
<p>给定无向图G=(V,E),任何一个由n个互不相同的顶点构成的序列就是H路径问题的一个证书；</p>
<p>如果图G有Hamilton路径，则该路径一定属于S；</p>
<p>8、P类问题和NP类问题：</p>
<p><strong>NP类问题是多项式时间可验证的；P类问题是多项式时间可解的；</strong></p>
<p>Hamilton路径问题的验证：<br>对于任给的一个证书即序列，只要逐一检查序列中相邻点之间是否有边相连；</p>
<p>若n-1个相邻点对均有边相连，则该序列是Hamilton路径，否则不是；</p>
<p>验证算法时间为Θ(n),故是多项式时间可验证的；</p>
<p><strong>NP完全问题是难处理的</strong>，迄今为止，未发现有NP完全问题的多项式时间求解方案；</p>
<p>9、规约：</p>
<p>设IA是判定问题A的任一个实例，B是另一判定问题，若存在一个从A到B的映射f满足一定条件，则称问题A可多项式变换为B，记作A≤pB(≤p亦称Karp规约)</p>
<p>若A≤pB且问题B是多项式时间可判定的，则问题A也一定是多项式时间可判定的；</p>
<p>10、NP完全问题的实例：</p>
<p>(1) k-团问题</p>
<p>(2) 顶点覆盖：</p>
<p>① 最优化问题：在一个无向图G中，找一个顶点数最少的顶点集，满足：任一条边的两个顶点中至少有一个在此集合中；</p>
<p>② 判定问题：无向图G中是否存在顶点数为k的顶点覆盖；</p>
<p>(3) 子集和问题：</p>
<p>(4) 限制法：</p>
<p>(5) 背包问题：</p>
<p>11、NP-hard类问题的求解方法：</p>
<p>(1) 当n不太大时，可使用①动态规划法，②分支限界法，③回溯法</p>
<p>(2) 求近似解，在误差允许范围内找一个解，该近似解可以在多项式时间里得到；</p>
<p>(3) 用启发式算法求解，根据具体问题设计启发式搜素策略，在理论上往往缺乏严格证明，用实验数据说明算法很有效；</p>
<p>(4) 只能优化算法，常常能获得很好的结果，但有偶然性，与最优解的误差难以给出；</p>
<h3 id="9-近似算法"><a href="#9-近似算法" class="headerlink" title="9 近似算法"></a>9 近似算法</h3><p>所有的NP完全问题，均未能找到多项式时间的算法，故当问题规模较大时，求得最优的精确解的可能性很小；</p>
<p>在此情况下，往往退而去求比最优精确解稍差一点的解作为问题的近似答案；</p>
<p>1、近似算法的性能：</p>
<p>近似算法一般都比较简单，但设计近似算法时必须关注所设计的算法得到的近似解与最优解之间的差距到底有多大；</p>
<p>2、近似方案：</p>
<blockquote>
<p>常数近似比的近似算法</p>
<p>多项式时间近似方案</p>
<p>完全多项式时间近似方案</p>
</blockquote>
<p>3、装箱问题：(bin packing)</p>
<p>(1) First-Fit(FF)算法</p>
<p>从排在最前面的箱子开始，对每个箱子剩余体积逐一进行检查，一旦碰到第一个能够装进当前物体的箱子时，就立即把这个物体装进箱子。对每个物体反复执行上述过程。</p>
<p>算法的最坏时间复杂度为O(n^2)</p>
<p>用FF算法不能保证所获得的解是最优解。</p>
<p>(2) Next-Fit(NF)算法</p>
<p>先把第一个空箱置为当前箱。然后依次把物品装箱，若当前箱放的下则放，否则放入下一个箱子，并指向下一个箱子。</p>
<p>算法的最坏复杂度为O(n),因为对每个物品只检查当前的箱子。</p>
<p>(3) Best-Fit(BF)算法</p>
<p>FF算法的修改，在已装有物品的箱子中，找一个既能放下ui,又能使其剩余空间最小的箱子来放ui。</p>
<p>BF算法在最坏情况下本质上和FF相同。</p>
<p>(4) First-Fit Decreasing(FFD)算法</p>
<p>先将所有物品从大到小排序，然后再使用FF法</p>
<p>4、顶点覆盖问题：</p>
<p>顶点覆盖问题就是要求在一个给定的无向图中，找出一个就有最小规模的顶点覆盖</p>
<p>5、旅行商问题：</p>
<p>旅行商问题(TSP)简单描述：</p>
<p>给定一个完全无向图G=(V, E),其每一边(u,v)属于E有一非负整数代价u(u,v)</p>
<p>要找出G中具有最小代价的哈密尔顿回路；</p>
<p>TSP的特殊性质：</p>
<p>代价函数c往往具有三角不等式性质，即对任意的3个顶点u,v,w属于V，有c(u,w)≤c(u,v)+c(v,w)</p>
<p>当图G中的顶点就是平面上的点，任意2顶点间的代价就是这2点间的欧氏距离时，代价函数c就具有三角不等式性质。 </p>

    </div>
    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="http://cheertt.top" target="_blank">cheertt</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/p/39949.html" class="pre-post btn btn-default" title='cs231n的NumPy教程'>
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">cs231n的NumPy教程</span>
        </a>
    
    
        <a href="/p/46253.html" class="next-post btn btn-default" title='彭明辉-研究生手册'>
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">彭明辉-研究生手册</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
	
    <div id="vcomments" class="valine"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>

    <script>
        new Valine({
            av: AV,
            el: '#vcomments',
            appId: 'xOKV9J4UeQAtVkvnJC7Kq2Jn-gzGzoHsz',
            appKey: 'erIpQac4azoCmgfBB7Dl9maa',
            placeholder: '说点什么吧',
            notify: false,
            verify: true,
            avatar: 'mm',
            meta: 'nick,mail'.split(','),
            pageSize: '10',
            path: window.location.pathname,
            lang: 'zh-CN'.toLowerCase()
        })
    </script>


    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-算法的基本概念"><span class="toc-text">1 算法的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-递归与分治"><span class="toc-text">2 递归与分治</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-动态规划"><span class="toc-text">3 动态规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-贪心算法"><span class="toc-text">4 贪心算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-随机算法"><span class="toc-text">5 随机算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-回溯法"><span class="toc-text">6 回溯法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-分支限界法"><span class="toc-text">7 分支限界法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-NP完全理论"><span class="toc-text">8 NP完全理论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-近似算法"><span class="toc-text">9 近似算法</span></a></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
        访问量:
        <strong id="busuanzi_value_site_pv">
            <i class="fa fa-spinner fa-spin"></i>
        </strong>
        &nbsp; | &nbsp;
        访客数:
        <strong id="busuanzi_value_site_uv">
            <i class="fa fa-spinner fa-spin"></i>
        </strong>
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2019
                </span> |
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>






    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<script src="/js/app.js?rev=@@hash"></script>

</body>
</html>